/* (c) 2014 Open Source Geospatial Foundation - all rights reserved
 * (c) 2001 - 2013 OpenPlans
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */
package org.geoserver.security.decorators;

import java.util.logging.Logger;

import org.geoserver.catalog.CoverageInfo;
import org.geoserver.catalog.CoverageStoreInfo;
import org.geoserver.catalog.DataStoreInfo;
import org.geoserver.catalog.FeatureTypeInfo;
import org.geoserver.catalog.LayerInfo;
import org.geoserver.catalog.WMSLayerInfo;
import org.geoserver.catalog.WMTSLayerInfo;
import org.geoserver.catalog.impl.ModificationProxy;
import org.geoserver.platform.ExtensionPriority;
import org.geoserver.security.WrapperPolicy;
import org.geotools.util.logging.Logging;

/**
 * Creates security wrappers for the most common catalog objects
 * 
 * @author Andrea Aime - TOPP
 * 
 */
public class DefaultSecureCatalogFactory implements SecuredObjectFactory {

    private static final Logger LOGGER = Logging.getLogger(DefaultSecureCatalogFactory.class);

    @Override
    public boolean canSecure(Class clazz) {
        return CoverageInfo.class.isAssignableFrom(clazz)
                || CoverageStoreInfo.class.isAssignableFrom(clazz)
                || DataStoreInfo.class.isAssignableFrom(clazz)
                || FeatureTypeInfo.class.isAssignableFrom(clazz)
                || LayerInfo.class.isAssignableFrom(clazz);
    }

    @Override
    public Object secure(Object object, WrapperPolicy policy) {
        // null safe
        if (object == null)
            return null;

        Class clazz = object.getClass();
        if (CoverageInfo.class.isAssignableFrom(clazz))
            return new SecuredCoverageInfo(unwrap((CoverageInfo) object), policy);
        else if (CoverageStoreInfo.class.isAssignableFrom(clazz))
            return new SecuredCoverageStoreInfo(unwrap((CoverageStoreInfo) object), policy);
        else if (DataStoreInfo.class.isAssignableFrom(clazz))
            return new SecuredDataStoreInfo(unwrap((DataStoreInfo) object), policy);
        else if (FeatureTypeInfo.class.isAssignableFrom(clazz))
            return new SecuredFeatureTypeInfo(unwrap((FeatureTypeInfo) object), policy);
        else if (LayerInfo.class.isAssignableFrom(clazz))
            return new SecuredLayerInfo(unwrap((LayerInfo) object), policy);
        else if (WMSLayerInfo.class.isAssignableFrom(clazz))
            return new SecuredWMSLayerInfo(unwrap((WMSLayerInfo) object), policy);
        else if (WMTSLayerInfo.class.isAssignableFrom(clazz))
            return new SecuredWMTSLayerInfo(unwrap((WMTSLayerInfo) object), policy);
        else
            throw new IllegalArgumentException("Don't know how to wrap " + object);
    }
    /**
     * Returns {@link ExtensionPriority#LOWEST} since the wrappers generated by
     * this factory
     * @return {@link ExtensionPriority#LOWEST}
     */
    @Override
    public int getPriority() {
        return ExtensionPriority.LOWEST;
    }

    private void logDoubleWrap(Object unwrapped, Object orig) {
        String msg = String.format("Tried to double secure: %s already securing %s", orig, unwrapped);
        LOGGER.warning(msg);
    }

    private void logDoubleWrap(final DataStoreInfo store) {
        int proxies = 0;
        int secured = 0;
        DataStoreInfo object = store;
        while (true) {
            DataStoreInfo unwrapped;
            if (object instanceof SecuredDataStoreInfo) {
                secured++;
                unwrapped = ((SecuredDataStoreInfo) object).unwrap(DataStoreInfo.class);
            } else {
                unwrapped = ModificationProxy.unwrap(object);
                boolean isProxy = object != unwrapped;
                if (isProxy) {
                    proxies++;
                } else {
                    break;
                }
            }
            object = unwrapped;
        }

        String msg = String.format("Double securing %s: proxies: %,d, SecuredDataStoreInfos: %,d",
                store.getName(), proxies, secured);
        LOGGER.warning(msg);
    }

    private WMTSLayerInfo unwrap(WMTSLayerInfo object) {
        WMTSLayerInfo unwrapped = ModificationProxy.unwrap(object);
        if(unwrapped instanceof SecuredWMTSLayerInfo) {
            logDoubleWrap(unwrapped, object);
        }
        return object;
    }

    private WMSLayerInfo unwrap(WMSLayerInfo object) {
        WMSLayerInfo unwrapped = ModificationProxy.unwrap(object);
        if(unwrapped instanceof SecuredWMSLayerInfo) {
            logDoubleWrap(unwrapped, object);
        }
        return object;
    }

    private LayerInfo unwrap(LayerInfo object) {
        LayerInfo unwrapped = ModificationProxy.unwrap(object);
        if(unwrapped instanceof SecuredLayerInfo) {
            logDoubleWrap(unwrapped, object);
        }
        return object;
    }

    private FeatureTypeInfo unwrap(FeatureTypeInfo object) {
        FeatureTypeInfo unwrapped = ModificationProxy.unwrap(object);
        if(unwrapped instanceof SecuredFeatureTypeInfo) {
            logDoubleWrap(unwrapped, object);
        }
        return object;
    }

    private CoverageStoreInfo unwrap(CoverageStoreInfo object) {
        CoverageStoreInfo unwrapped = ModificationProxy.unwrap(object);
        if(unwrapped instanceof SecuredCoverageStoreInfo) {
            logDoubleWrap(unwrapped, object);
        }
        return object;
    }

    private CoverageInfo unwrap(CoverageInfo object) {
        CoverageInfo unwrapped = ModificationProxy.unwrap(object);
        if(unwrapped instanceof SecuredDataStoreInfo) {
            logDoubleWrap(unwrapped, object);
        }
        return object;
    }

    private DataStoreInfo unwrap(DataStoreInfo object) {
        DataStoreInfo unwrapped = ModificationProxy.unwrap(object);
        if(unwrapped instanceof SecuredDataStoreInfo) {
            logDoubleWrap(object);
        }
        return object;
    }

}
